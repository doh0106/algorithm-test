아래 **Cheat Sheet**는 코딩 테스트 문제를 **하나의 작은 프로젝트**로 보고,  
“문서 작성 → 설계 → 구현 → 검증” 과정을 체계적으로 정리한 것입니다.  
추가로, **TDD**(Test-Driven Development), **시공간 복잡도 측정 데코레이터**, **입출력 로깅** 등을 어떻게 녹여내는지도 함께 안내합니다.

---

# **코딩 테스트 = 미니 프로젝트 Cheat Sheet**

## 1. **프로젝트(문제) 분석 및 문서화**

1) **프로젝트 개요(문제 개요) 문서**  
   - **문제 목표**: 문제에서 구체적으로 요구하는 것 (예: "배열에서 짝수만 골라 합 구하기").  
   - **입력/출력 명세**: 어떤 형식으로 입력이 주어지고, 어떤 값을 반환해야 하는지 명확히 정리.  
   - **제약사항(Constraints)**: 시간 복잡도나 메모리 사용량 제한, 입력 데이터 범위(예: 1 ≤ N ≤ 10^6).  
   - **예제 분석**: 주어진 예제 입출력과, 가능하면 엣지 케이스도 미리 작성.

2) **요구사항 명세**  
   - **기능 요구사항**: 필수 기능, 예외 처리, 출력 형식 등.  
   - **비기능 요구사항**: 성능(시간/메모리), 코드 가독성, 유지보수성 등.

> 예)  
> - **기능 요구사항**: 배열의 짝수만 골라 합산한다.  
> - **비기능 요구사항**: O(N) 이내로 처리할 것, 메모리 사용량 512MB 이하 등.

---

## 2. **설계 단계(TDD 및 로직 구상)**

1) **알고리즘 및 자료구조 설계**  
   - **접근 방식**: 브루트포스, 투 포인터, DFS/BFS, 다이나믹 프로그래밍 등 결정.  
   - **자료구조**: 리스트, 해시맵, 트리, 그래프, 스택/큐 등 필요한 구조 선정.  
   - **복잡도 분석**: 시간복잡도(O(N), O(N log N) 등), 공간복잡도.

2) **TDD 계획 수립**  
   - **테스트 케이스** 미리 작성(실패하는 테스트부터 만든다).  
   - **테스트 범위**: 정상 입력, 엣지 케이스(최대/최소, 빈 값 등).

3) **함수 분할 설계**  
   - **주요 로직 함수**: 예) `filter_even(nums)`, `sum_list(nums)`.  
   - **메인 솔루션 함수**: 예) `solution(nums)`.  
   - **테스트 함수**(혹은 `unittest`) 설계.

---

## 3. **구현 단계**

1) **데코레이터 적용**  
   - **시간·메모리 측정 데코레이터(`measure_performance`)**  
     - 각 함수 실행 시간을 기록하고, 메모리 사용량(최대/현재)을 출력.  
   - **입출력 로깅 데코레이터(`log_input_output`)**  
     - 함수가 호출될 때, 함수명과 입력(인자), 출력(결과값)을 자동 로그로 남김.

2) **TDD에 따른 코드 작성**  
   1. **Fail**: 테스트 코드를 먼저 작성(예: assert를 통해 기대 결과와 비교).  
   2. **Green**: 최소한의 코드로 테스트 통과.  
   3. **Refactor**: 코드 구조 개선, 중복 제거, 최적화.

3) **중간 디버깅**  
   - 각 함수가 제대로 동작하는지 **로그**(입출력)와 **시공간 측정 결과**를 확인.  
   - 필요시 알고리즘 최적화(예: 중복 로직 제거, 더 효율적인 자료구조 사용).

> 예)  
> ```python
> @measure_performance
> @log_input_output
> def solution(nums):
>     return sum(x for x in nums if x % 2 == 0)
> ```

---

## 4. **검증 및 테스트 단계**

1) **단위 테스트 수행**  
   - 작성해둔 **테스트 케이스**들을 실행해서 전부 통과 여부 확인.  
   - 실패 시: AssertionError → 코드 수정 후 재테스트 (TDD 반복).

2) **추가 검증**  
   - **엣지 케이스**: 빈 배열, 최대 크기 배열, 음수/0 포함 등.  
   - **소요 시간 및 메모리 확인**: 데코레이터 출력 로그로 확인하고, 제한 사항 충족 여부 파악.

3) **결과 문서화**  
   - “테스트 케이스: 입력 - 출력 - 결과(성공/실패)” 형태로 간단히 정리해두면 재활용 가능.

---

## 5. **최종 마무리 및 제출**

1) **정리 문서**  
   - **핵심 로직 설명**: 어떤 접근/자료구조를 썼는지, 왜 그렇게 결정했는지.  
   - **복잡도 분석**: 실제 측정값(데코레이터 로그)과 이론적 분석 결과가 일치하는지.  
   - **한계 및 향후 개선**: 더 최적화할 여지나 보완점.

2) **코딩 테스트 제출**  
   - 플랫폼 규칙에 맞춰 **함수만 복사**하거나 **전체 스크립트** 붙여넣기.  
   - 통과 여부 확인 후 필요시 리팩토링/재제출.

3) **피드백 반영** (선택)  
   - 만약 동일 유형의 문제가 다시 나온다면, 이번 설계를 어떻게 보완할지 생각해볼 것.

---

# **정리된 Cheat Sheet 흐름**

1. **문제(프로젝트) 분석**  
   - 목표, 요구사항, 제약 파악  
   - 예제/엣지 케이스 조사  
2. **설계**  
   - 알고리즘 선택, 자료구조, 복잡도 분석  
   - TDD 테스트 케이스 준비  
3. **구현**  
   - 데코레이터(시간·메모리, 입출력 로깅) 적용  
   - TDD(실패→성공→리팩토링) 사이클  
4. **검증**  
   - 테스트 케이스 전체 통과  
   - 시·공간 성능 확인  
5. **최종 제출**  
   - 요약 문서(설계, 복잡도, 테스트 결과)  
   - 실제 코딩 테스트 플랫폼에 붙여넣기 or 제출  
---

# 장단점
## **1. 장점**
1. **체계적 문제 해결**  
   - 프로젝트 관점에서 문제를 접근하면, 문제를 **분석**하고 **설계**하는 시간을 늘릴 수 있어 실수 가능성이 줄어듦.  
   - 특히, 복잡한 문제에서 문제를 **서브 문제로 분리**하는 습관은 매우 유용.

2. **TDD와 데코레이터 활용으로 디버깅 용이**  
   - 실패한 테스트 케이스가 자동으로 기록되고, 로깅과 시간/메모리 추적이 병행되면 문제의 **병목 지점**을 빠르게 파악 가능.  

3. **복잡도 고려가 습관화됨**  
   - 설계 단계에서 시간/공간 복잡도를 먼저 고려하면, 처음부터 최적화된 알고리즘을 구상할 가능성이 높아짐.  

4. **재사용 가능**  
   - 문서화와 구조적 접근 덕분에 **유사한 유형의 문제를 다시 만났을 때** 해결 속도가 빨라짐.  

---

## **2. 한계**
1. **코딩 테스트의 시간 제약**  
   - 대부분 코딩 테스트는 1~2시간 안에 문제를 해결해야 하므로,  
     "문제 분석 및 설계"에 너무 많은 시간을 할애하면 구현 시간이 부족할 수 있음.

2. **테스트 케이스 설계의 비중**  
   - 테스트 케이스 작성은 TDD의 필수 요소지만, 제한된 시간 안에서  
     이를 작성하고 코드에 반영하는 게 현실적으로 어려운 경우도 있음.  

3. **간단한 문제엔 과한 접근**  
   - 예를 들어, "정렬된 배열에서 최댓값 찾기" 같은 단순 문제는 프로젝트 접근보다 빠른 구현이 더 효율적.  
   - 즉, 문제의 난이도와 복잡도에 따라 가볍게 접근해야 할 때도 있음.

---

## **3. 더 효율적인 대안**
현실적인 코딩 테스트 환경에 맞추어 **시간 효율성을 높이기 위한 보완 아이디어**를 제안합니다.

### **3.1. 문제 유형별 전략 적용**
모든 문제를 프로젝트처럼 접근하는 것은 비효율적일 수 있습니다.  
문제를 **유형별로 다르게 접근**하는 전략을 도입해보세요.

| 문제 유형           | 접근 방식                                                                                                                                                   |
|--------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------|
| 간단한 문제        | - 분석/설계를 생략하고 바로 구현 시작.                                                                                                                          |
| 알고리즘 중점 문제  | - **문제 분석 → 설계 → 구현 → 검증**의 기본 단계를 유지하되, 설계에 5~10분 제한.                                                                                |
| 복잡한 문제        | - 현재 접근 방식(프로젝트 관점) 그대로 진행. 문제를 작은 서브 문제로 나누고 단계별 구현.                                                                            |

---

### **3.2. TDD 활용을 간소화**
테스트 코드 작성이 시간이 오래 걸릴 수 있으므로, 아래처럼 간단히 처리합니다:
- **최소한의 테스트 코드 작성:**  
  문제에서 주어진 예제와 1~2개의 엣지 케이스만 작성.
- **수동 검증 추가:**  
  테스트 함수를 작성하는 대신, **디버깅용으로 출력**.

```python
# TDD 대신 간단한 검증 코드
nums = [1, 2, 3, 4, 5]
print(solution(nums))  # Expected: 6
```

---

### **3.3. 데코레이터 선택적 사용**
데코레이터는 매우 유용하지만, 모든 함수에 적용할 필요는 없습니다.
- **복잡도가 의심되는 핵심 함수에만 적용.**
- 예를 들어:
```python
@measure_performance
def core_algorithm(nums):
    ...
```

---

### **3.4. 사전 연습과 템플릿 활용**
코딩 테스트에서 시간을 절약하려면, 아래를 미리 준비해두세요:
1. **템플릿 코드 작성**  
   - 데코레이터나 간단한 테스트 함수를 포함한 기본 구조를 미리 준비.  
   - 실제 코딩 테스트 시작 시 바로 복사해서 사용.  

2. **유형별 풀이 연습**  
   - 문제를 유형별(정렬, DP, 그래프 탐색 등)로 분류하고 각 유형에 맞는 풀이 전략을 미리 숙지.

---

## **4. 결론: 접근 방식 평가**
당신의 **"코테 = 작은 프로젝트"** 접근 방식은 매우 체계적이고,  
**효율성**과 **문제 해결 능력 향상**이라는 관점에서 훌륭합니다.  

다만, 제한된 시간 내에 **문제를 완벽히 풀어야 하는 현실**을 고려해,  
아래를 조합해 사용하는 것을 추천합니다:
1. 문제 유형에 따라 **프로젝트 접근 vs 빠른 구현**을 결정.  
2. TDD와 데코레이터를 **필요한 곳에만 선택적으로 적용.**  
3. 기본 템플릿과 반복 연습으로 시간을 단축.

이렇게 하면 **체계적인 접근법의 장점**은 살리면서도,  
**실제 코딩 테스트 환경에서의 시간 제약**을 극복할 수 있을 것입니다. 
이 과정만 따라가도, **코딩 테스트 문제를 마치 작은 프로젝트처럼** 깔끔하게 분석·설계·구현·검증할 수 있습니다.  
**TDD**와 **시공간 측정/로깅**은 코드를 **안정적**이고 **검증 가능**하게 만들어 줄 것입니다!  